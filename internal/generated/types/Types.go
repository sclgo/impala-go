// Code generated by Thrift Compiler (0.22.0). DO NOT EDIT.

package types

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"iter"
	"log/slog"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = bytes.Equal
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = iter.Pull[int]
var _ = slog.Log
var _ = time.Now
var _ = thrift.ZERO
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

type TPrimitiveType int64

const (
	TPrimitiveType_INVALID_TYPE TPrimitiveType = 0
	TPrimitiveType_NULL_TYPE TPrimitiveType = 1
	TPrimitiveType_BOOLEAN TPrimitiveType = 2
	TPrimitiveType_TINYINT TPrimitiveType = 3
	TPrimitiveType_SMALLINT TPrimitiveType = 4
	TPrimitiveType_INT TPrimitiveType = 5
	TPrimitiveType_BIGINT TPrimitiveType = 6
	TPrimitiveType_FLOAT TPrimitiveType = 7
	TPrimitiveType_DOUBLE TPrimitiveType = 8
	TPrimitiveType_DATE TPrimitiveType = 9
	TPrimitiveType_DATETIME TPrimitiveType = 10
	TPrimitiveType_TIMESTAMP TPrimitiveType = 11
	TPrimitiveType_STRING TPrimitiveType = 12
	TPrimitiveType_BINARY TPrimitiveType = 13
	TPrimitiveType_DECIMAL TPrimitiveType = 14
	TPrimitiveType_CHAR TPrimitiveType = 15
	TPrimitiveType_VARCHAR TPrimitiveType = 16
	TPrimitiveType_FIXED_UDA_INTERMEDIATE TPrimitiveType = 17
)

var knownTPrimitiveTypeValues = []TPrimitiveType{
	TPrimitiveType_INVALID_TYPE,
	TPrimitiveType_NULL_TYPE,
	TPrimitiveType_BOOLEAN,
	TPrimitiveType_TINYINT,
	TPrimitiveType_SMALLINT,
	TPrimitiveType_INT,
	TPrimitiveType_BIGINT,
	TPrimitiveType_FLOAT,
	TPrimitiveType_DOUBLE,
	TPrimitiveType_DATE,
	TPrimitiveType_DATETIME,
	TPrimitiveType_TIMESTAMP,
	TPrimitiveType_STRING,
	TPrimitiveType_BINARY,
	TPrimitiveType_DECIMAL,
	TPrimitiveType_CHAR,
	TPrimitiveType_VARCHAR,
	TPrimitiveType_FIXED_UDA_INTERMEDIATE,
}

func TPrimitiveTypeValues() iter.Seq[TPrimitiveType] {
	return func(yield func(TPrimitiveType) bool) {
		for _, v := range knownTPrimitiveTypeValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TPrimitiveType) String() string {
	switch p {
	case TPrimitiveType_INVALID_TYPE: return "INVALID_TYPE"
	case TPrimitiveType_NULL_TYPE: return "NULL_TYPE"
	case TPrimitiveType_BOOLEAN: return "BOOLEAN"
	case TPrimitiveType_TINYINT: return "TINYINT"
	case TPrimitiveType_SMALLINT: return "SMALLINT"
	case TPrimitiveType_INT: return "INT"
	case TPrimitiveType_BIGINT: return "BIGINT"
	case TPrimitiveType_FLOAT: return "FLOAT"
	case TPrimitiveType_DOUBLE: return "DOUBLE"
	case TPrimitiveType_DATE: return "DATE"
	case TPrimitiveType_DATETIME: return "DATETIME"
	case TPrimitiveType_TIMESTAMP: return "TIMESTAMP"
	case TPrimitiveType_STRING: return "STRING"
	case TPrimitiveType_BINARY: return "BINARY"
	case TPrimitiveType_DECIMAL: return "DECIMAL"
	case TPrimitiveType_CHAR: return "CHAR"
	case TPrimitiveType_VARCHAR: return "VARCHAR"
	case TPrimitiveType_FIXED_UDA_INTERMEDIATE: return "FIXED_UDA_INTERMEDIATE"
	}
	return "<UNSET>"
}

func TPrimitiveTypeFromString(s string) (TPrimitiveType, error) {
	switch s {
	case "INVALID_TYPE": return TPrimitiveType_INVALID_TYPE, nil
	case "NULL_TYPE": return TPrimitiveType_NULL_TYPE, nil
	case "BOOLEAN": return TPrimitiveType_BOOLEAN, nil
	case "TINYINT": return TPrimitiveType_TINYINT, nil
	case "SMALLINT": return TPrimitiveType_SMALLINT, nil
	case "INT": return TPrimitiveType_INT, nil
	case "BIGINT": return TPrimitiveType_BIGINT, nil
	case "FLOAT": return TPrimitiveType_FLOAT, nil
	case "DOUBLE": return TPrimitiveType_DOUBLE, nil
	case "DATE": return TPrimitiveType_DATE, nil
	case "DATETIME": return TPrimitiveType_DATETIME, nil
	case "TIMESTAMP": return TPrimitiveType_TIMESTAMP, nil
	case "STRING": return TPrimitiveType_STRING, nil
	case "BINARY": return TPrimitiveType_BINARY, nil
	case "DECIMAL": return TPrimitiveType_DECIMAL, nil
	case "CHAR": return TPrimitiveType_CHAR, nil
	case "VARCHAR": return TPrimitiveType_VARCHAR, nil
	case "FIXED_UDA_INTERMEDIATE": return TPrimitiveType_FIXED_UDA_INTERMEDIATE, nil
	}
	return TPrimitiveType(0), fmt.Errorf("not a valid TPrimitiveType string")
}


func TPrimitiveTypePtr(v TPrimitiveType) *TPrimitiveType { return &v }

func (p TPrimitiveType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TPrimitiveType) UnmarshalText(text []byte) error {
	q, err := TPrimitiveTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TPrimitiveType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TPrimitiveType(v)
	return nil
}

func (p *TPrimitiveType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TTypeNodeType int64

const (
	TTypeNodeType_SCALAR TTypeNodeType = 0
	TTypeNodeType_ARRAY TTypeNodeType = 1
	TTypeNodeType_MAP TTypeNodeType = 2
	TTypeNodeType_STRUCT TTypeNodeType = 3
)

var knownTTypeNodeTypeValues = []TTypeNodeType{
	TTypeNodeType_SCALAR,
	TTypeNodeType_ARRAY,
	TTypeNodeType_MAP,
	TTypeNodeType_STRUCT,
}

func TTypeNodeTypeValues() iter.Seq[TTypeNodeType] {
	return func(yield func(TTypeNodeType) bool) {
		for _, v := range knownTTypeNodeTypeValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TTypeNodeType) String() string {
	switch p {
	case TTypeNodeType_SCALAR: return "SCALAR"
	case TTypeNodeType_ARRAY: return "ARRAY"
	case TTypeNodeType_MAP: return "MAP"
	case TTypeNodeType_STRUCT: return "STRUCT"
	}
	return "<UNSET>"
}

func TTypeNodeTypeFromString(s string) (TTypeNodeType, error) {
	switch s {
	case "SCALAR": return TTypeNodeType_SCALAR, nil
	case "ARRAY": return TTypeNodeType_ARRAY, nil
	case "MAP": return TTypeNodeType_MAP, nil
	case "STRUCT": return TTypeNodeType_STRUCT, nil
	}
	return TTypeNodeType(0), fmt.Errorf("not a valid TTypeNodeType string")
}


func TTypeNodeTypePtr(v TTypeNodeType) *TTypeNodeType { return &v }

func (p TTypeNodeType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TTypeNodeType) UnmarshalText(text []byte) error {
	q, err := TTypeNodeTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TTypeNodeType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TTypeNodeType(v)
	return nil
}

func (p *TTypeNodeType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TStmtType int64

const (
	TStmtType_QUERY TStmtType = 0
	TStmtType_DDL TStmtType = 1
	TStmtType_DML TStmtType = 2
	TStmtType_EXPLAIN TStmtType = 3
	TStmtType_LOAD TStmtType = 4
	TStmtType_SET TStmtType = 5
	TStmtType_ADMIN_FN TStmtType = 6
	TStmtType_TESTCASE TStmtType = 7
	TStmtType_CONVERT TStmtType = 8
	TStmtType_UNKNOWN TStmtType = 9
	TStmtType_KILL TStmtType = 10
)

var knownTStmtTypeValues = []TStmtType{
	TStmtType_QUERY,
	TStmtType_DDL,
	TStmtType_DML,
	TStmtType_EXPLAIN,
	TStmtType_LOAD,
	TStmtType_SET,
	TStmtType_ADMIN_FN,
	TStmtType_TESTCASE,
	TStmtType_CONVERT,
	TStmtType_UNKNOWN,
	TStmtType_KILL,
}

func TStmtTypeValues() iter.Seq[TStmtType] {
	return func(yield func(TStmtType) bool) {
		for _, v := range knownTStmtTypeValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TStmtType) String() string {
	switch p {
	case TStmtType_QUERY: return "QUERY"
	case TStmtType_DDL: return "DDL"
	case TStmtType_DML: return "DML"
	case TStmtType_EXPLAIN: return "EXPLAIN"
	case TStmtType_LOAD: return "LOAD"
	case TStmtType_SET: return "SET"
	case TStmtType_ADMIN_FN: return "ADMIN_FN"
	case TStmtType_TESTCASE: return "TESTCASE"
	case TStmtType_CONVERT: return "CONVERT"
	case TStmtType_UNKNOWN: return "UNKNOWN"
	case TStmtType_KILL: return "KILL"
	}
	return "<UNSET>"
}

func TStmtTypeFromString(s string) (TStmtType, error) {
	switch s {
	case "QUERY": return TStmtType_QUERY, nil
	case "DDL": return TStmtType_DDL, nil
	case "DML": return TStmtType_DML, nil
	case "EXPLAIN": return TStmtType_EXPLAIN, nil
	case "LOAD": return TStmtType_LOAD, nil
	case "SET": return TStmtType_SET, nil
	case "ADMIN_FN": return TStmtType_ADMIN_FN, nil
	case "TESTCASE": return TStmtType_TESTCASE, nil
	case "CONVERT": return TStmtType_CONVERT, nil
	case "UNKNOWN": return TStmtType_UNKNOWN, nil
	case "KILL": return TStmtType_KILL, nil
	}
	return TStmtType(0), fmt.Errorf("not a valid TStmtType string")
}


func TStmtTypePtr(v TStmtType) *TStmtType { return &v }

func (p TStmtType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TStmtType) UnmarshalText(text []byte) error {
	q, err := TStmtTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TStmtType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TStmtType(v)
	return nil
}

func (p *TStmtType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TIcebergOperation int64

const (
	TIcebergOperation_INSERT TIcebergOperation = 0
	TIcebergOperation_DELETE TIcebergOperation = 1
	TIcebergOperation_UPDATE TIcebergOperation = 2
	TIcebergOperation_OPTIMIZE TIcebergOperation = 3
	TIcebergOperation_MERGE TIcebergOperation = 4
)

var knownTIcebergOperationValues = []TIcebergOperation{
	TIcebergOperation_INSERT,
	TIcebergOperation_DELETE,
	TIcebergOperation_UPDATE,
	TIcebergOperation_OPTIMIZE,
	TIcebergOperation_MERGE,
}

func TIcebergOperationValues() iter.Seq[TIcebergOperation] {
	return func(yield func(TIcebergOperation) bool) {
		for _, v := range knownTIcebergOperationValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TIcebergOperation) String() string {
	switch p {
	case TIcebergOperation_INSERT: return "INSERT"
	case TIcebergOperation_DELETE: return "DELETE"
	case TIcebergOperation_UPDATE: return "UPDATE"
	case TIcebergOperation_OPTIMIZE: return "OPTIMIZE"
	case TIcebergOperation_MERGE: return "MERGE"
	}
	return "<UNSET>"
}

func TIcebergOperationFromString(s string) (TIcebergOperation, error) {
	switch s {
	case "INSERT": return TIcebergOperation_INSERT, nil
	case "DELETE": return TIcebergOperation_DELETE, nil
	case "UPDATE": return TIcebergOperation_UPDATE, nil
	case "OPTIMIZE": return TIcebergOperation_OPTIMIZE, nil
	case "MERGE": return TIcebergOperation_MERGE, nil
	}
	return TIcebergOperation(0), fmt.Errorf("not a valid TIcebergOperation string")
}


func TIcebergOperationPtr(v TIcebergOperation) *TIcebergOperation { return &v }

func (p TIcebergOperation) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TIcebergOperation) UnmarshalText(text []byte) error {
	q, err := TIcebergOperationFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TIcebergOperation) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TIcebergOperation(v)
	return nil
}

func (p *TIcebergOperation) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TExplainLevel int64

const (
	TExplainLevel_MINIMAL TExplainLevel = 0
	TExplainLevel_STANDARD TExplainLevel = 1
	TExplainLevel_EXTENDED TExplainLevel = 2
	TExplainLevel_VERBOSE TExplainLevel = 3
)

var knownTExplainLevelValues = []TExplainLevel{
	TExplainLevel_MINIMAL,
	TExplainLevel_STANDARD,
	TExplainLevel_EXTENDED,
	TExplainLevel_VERBOSE,
}

func TExplainLevelValues() iter.Seq[TExplainLevel] {
	return func(yield func(TExplainLevel) bool) {
		for _, v := range knownTExplainLevelValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TExplainLevel) String() string {
	switch p {
	case TExplainLevel_MINIMAL: return "MINIMAL"
	case TExplainLevel_STANDARD: return "STANDARD"
	case TExplainLevel_EXTENDED: return "EXTENDED"
	case TExplainLevel_VERBOSE: return "VERBOSE"
	}
	return "<UNSET>"
}

func TExplainLevelFromString(s string) (TExplainLevel, error) {
	switch s {
	case "MINIMAL": return TExplainLevel_MINIMAL, nil
	case "STANDARD": return TExplainLevel_STANDARD, nil
	case "EXTENDED": return TExplainLevel_EXTENDED, nil
	case "VERBOSE": return TExplainLevel_VERBOSE, nil
	}
	return TExplainLevel(0), fmt.Errorf("not a valid TExplainLevel string")
}


func TExplainLevelPtr(v TExplainLevel) *TExplainLevel { return &v }

func (p TExplainLevel) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TExplainLevel) UnmarshalText(text []byte) error {
	q, err := TExplainLevelFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TExplainLevel) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TExplainLevel(v)
	return nil
}

func (p *TExplainLevel) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TRuntimeFilterMode int64

const (
	TRuntimeFilterMode_OFF TRuntimeFilterMode = 0
	TRuntimeFilterMode_LOCAL TRuntimeFilterMode = 1
	TRuntimeFilterMode_GLOBAL TRuntimeFilterMode = 2
)

var knownTRuntimeFilterModeValues = []TRuntimeFilterMode{
	TRuntimeFilterMode_OFF,
	TRuntimeFilterMode_LOCAL,
	TRuntimeFilterMode_GLOBAL,
}

func TRuntimeFilterModeValues() iter.Seq[TRuntimeFilterMode] {
	return func(yield func(TRuntimeFilterMode) bool) {
		for _, v := range knownTRuntimeFilterModeValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TRuntimeFilterMode) String() string {
	switch p {
	case TRuntimeFilterMode_OFF: return "OFF"
	case TRuntimeFilterMode_LOCAL: return "LOCAL"
	case TRuntimeFilterMode_GLOBAL: return "GLOBAL"
	}
	return "<UNSET>"
}

func TRuntimeFilterModeFromString(s string) (TRuntimeFilterMode, error) {
	switch s {
	case "OFF": return TRuntimeFilterMode_OFF, nil
	case "LOCAL": return TRuntimeFilterMode_LOCAL, nil
	case "GLOBAL": return TRuntimeFilterMode_GLOBAL, nil
	}
	return TRuntimeFilterMode(0), fmt.Errorf("not a valid TRuntimeFilterMode string")
}


func TRuntimeFilterModePtr(v TRuntimeFilterMode) *TRuntimeFilterMode { return &v }

func (p TRuntimeFilterMode) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TRuntimeFilterMode) UnmarshalText(text []byte) error {
	q, err := TRuntimeFilterModeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TRuntimeFilterMode) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TRuntimeFilterMode(v)
	return nil
}

func (p *TRuntimeFilterMode) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TPrefetchMode int64

const (
	TPrefetchMode_NONE TPrefetchMode = 0
	TPrefetchMode_HT_BUCKET TPrefetchMode = 1
)

var knownTPrefetchModeValues = []TPrefetchMode{
	TPrefetchMode_NONE,
	TPrefetchMode_HT_BUCKET,
}

func TPrefetchModeValues() iter.Seq[TPrefetchMode] {
	return func(yield func(TPrefetchMode) bool) {
		for _, v := range knownTPrefetchModeValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TPrefetchMode) String() string {
	switch p {
	case TPrefetchMode_NONE: return "NONE"
	case TPrefetchMode_HT_BUCKET: return "HT_BUCKET"
	}
	return "<UNSET>"
}

func TPrefetchModeFromString(s string) (TPrefetchMode, error) {
	switch s {
	case "NONE": return TPrefetchMode_NONE, nil
	case "HT_BUCKET": return TPrefetchMode_HT_BUCKET, nil
	}
	return TPrefetchMode(0), fmt.Errorf("not a valid TPrefetchMode string")
}


func TPrefetchModePtr(v TPrefetchMode) *TPrefetchMode { return &v }

func (p TPrefetchMode) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TPrefetchMode) UnmarshalText(text []byte) error {
	q, err := TPrefetchModeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TPrefetchMode) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TPrefetchMode(v)
	return nil
}

func (p *TPrefetchMode) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TFunctionCategory int64

const (
	TFunctionCategory_SCALAR TFunctionCategory = 0
	TFunctionCategory_AGGREGATE TFunctionCategory = 1
	TFunctionCategory_ANALYTIC TFunctionCategory = 2
)

var knownTFunctionCategoryValues = []TFunctionCategory{
	TFunctionCategory_SCALAR,
	TFunctionCategory_AGGREGATE,
	TFunctionCategory_ANALYTIC,
}

func TFunctionCategoryValues() iter.Seq[TFunctionCategory] {
	return func(yield func(TFunctionCategory) bool) {
		for _, v := range knownTFunctionCategoryValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TFunctionCategory) String() string {
	switch p {
	case TFunctionCategory_SCALAR: return "SCALAR"
	case TFunctionCategory_AGGREGATE: return "AGGREGATE"
	case TFunctionCategory_ANALYTIC: return "ANALYTIC"
	}
	return "<UNSET>"
}

func TFunctionCategoryFromString(s string) (TFunctionCategory, error) {
	switch s {
	case "SCALAR": return TFunctionCategory_SCALAR, nil
	case "AGGREGATE": return TFunctionCategory_AGGREGATE, nil
	case "ANALYTIC": return TFunctionCategory_ANALYTIC, nil
	}
	return TFunctionCategory(0), fmt.Errorf("not a valid TFunctionCategory string")
}


func TFunctionCategoryPtr(v TFunctionCategory) *TFunctionCategory { return &v }

func (p TFunctionCategory) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TFunctionCategory) UnmarshalText(text []byte) error {
	q, err := TFunctionCategoryFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TFunctionCategory) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TFunctionCategory(v)
	return nil
}

func (p *TFunctionCategory) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TFunctionBinaryType int64

const (
	TFunctionBinaryType_BUILTIN TFunctionBinaryType = 0
	TFunctionBinaryType_JAVA TFunctionBinaryType = 1
	TFunctionBinaryType_NATIVE TFunctionBinaryType = 2
	TFunctionBinaryType_IR TFunctionBinaryType = 3
)

var knownTFunctionBinaryTypeValues = []TFunctionBinaryType{
	TFunctionBinaryType_BUILTIN,
	TFunctionBinaryType_JAVA,
	TFunctionBinaryType_NATIVE,
	TFunctionBinaryType_IR,
}

func TFunctionBinaryTypeValues() iter.Seq[TFunctionBinaryType] {
	return func(yield func(TFunctionBinaryType) bool) {
		for _, v := range knownTFunctionBinaryTypeValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TFunctionBinaryType) String() string {
	switch p {
	case TFunctionBinaryType_BUILTIN: return "BUILTIN"
	case TFunctionBinaryType_JAVA: return "JAVA"
	case TFunctionBinaryType_NATIVE: return "NATIVE"
	case TFunctionBinaryType_IR: return "IR"
	}
	return "<UNSET>"
}

func TFunctionBinaryTypeFromString(s string) (TFunctionBinaryType, error) {
	switch s {
	case "BUILTIN": return TFunctionBinaryType_BUILTIN, nil
	case "JAVA": return TFunctionBinaryType_JAVA, nil
	case "NATIVE": return TFunctionBinaryType_NATIVE, nil
	case "IR": return TFunctionBinaryType_IR, nil
	}
	return TFunctionBinaryType(0), fmt.Errorf("not a valid TFunctionBinaryType string")
}


func TFunctionBinaryTypePtr(v TFunctionBinaryType) *TFunctionBinaryType { return &v }

func (p TFunctionBinaryType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TFunctionBinaryType) UnmarshalText(text []byte) error {
	q, err := TFunctionBinaryTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TFunctionBinaryType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TFunctionBinaryType(v)
	return nil
}

func (p *TFunctionBinaryType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TSortingOrder int64

const (
	TSortingOrder_LEXICAL TSortingOrder = 0
	TSortingOrder_ZORDER TSortingOrder = 1
)

var knownTSortingOrderValues = []TSortingOrder{
	TSortingOrder_LEXICAL,
	TSortingOrder_ZORDER,
}

func TSortingOrderValues() iter.Seq[TSortingOrder] {
	return func(yield func(TSortingOrder) bool) {
		for _, v := range knownTSortingOrderValues {
			if !yield(v) {
				return
			}
		}
	}
}

func (p TSortingOrder) String() string {
	switch p {
	case TSortingOrder_LEXICAL: return "LEXICAL"
	case TSortingOrder_ZORDER: return "ZORDER"
	}
	return "<UNSET>"
}

func TSortingOrderFromString(s string) (TSortingOrder, error) {
	switch s {
	case "LEXICAL": return TSortingOrder_LEXICAL, nil
	case "ZORDER": return TSortingOrder_ZORDER, nil
	}
	return TSortingOrder(0), fmt.Errorf("not a valid TSortingOrder string")
}


func TSortingOrderPtr(v TSortingOrder) *TSortingOrder { return &v }

func (p TSortingOrder) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TSortingOrder) UnmarshalText(text []byte) error {
	q, err := TSortingOrderFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TSortingOrder) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TSortingOrder(v)
	return nil
}

func (p *TSortingOrder) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TTimestamp int64

func TTimestampPtr(v TTimestamp) *TTimestamp { return &v }

type TFragmentIdx int32

func TFragmentIdxPtr(v TFragmentIdx) *TFragmentIdx { return &v }

type TPlanNodeId int32

func TPlanNodeIdPtr(v TPlanNodeId) *TPlanNodeId { return &v }

type TDataSinkId int32

func TDataSinkIdPtr(v TDataSinkId) *TDataSinkId { return &v }

type TTupleId int32

func TTupleIdPtr(v TTupleId) *TTupleId { return &v }

type TSlotId int32

func TSlotIdPtr(v TSlotId) *TSlotId { return &v }

type TTableId int32

func TTableIdPtr(v TTableId) *TTableId { return &v }

type TBackendId *TUniqueId

func TBackendIdPtr(v TBackendId) *TBackendId { return &v }

// Attributes:
//  - Type
//  - Len
//  - Precision
//  - Scale
// 
type TScalarType struct {
	Type TPrimitiveType `thrift:"type,1,required" db:"type" json:"type"`
	Len *int32 `thrift:"len,2" db:"len" json:"len,omitempty"`
	Precision *int32 `thrift:"precision,3" db:"precision" json:"precision,omitempty"`
	Scale *int32 `thrift:"scale,4" db:"scale" json:"scale,omitempty"`
}

func NewTScalarType() *TScalarType {
	return &TScalarType{}
}



func (p *TScalarType) GetType() TPrimitiveType {
	return p.Type
}

var TScalarType_Len_DEFAULT int32

func (p *TScalarType) GetLen() int32 {
	if !p.IsSetLen() {
		return TScalarType_Len_DEFAULT
	}
	return *p.Len
}

var TScalarType_Precision_DEFAULT int32

func (p *TScalarType) GetPrecision() int32 {
	if !p.IsSetPrecision() {
		return TScalarType_Precision_DEFAULT
	}
	return *p.Precision
}

var TScalarType_Scale_DEFAULT int32

func (p *TScalarType) GetScale() int32 {
	if !p.IsSetScale() {
		return TScalarType_Scale_DEFAULT
	}
	return *p.Scale
}

func (p *TScalarType) IsSetLen() bool {
	return p.Len != nil
}

func (p *TScalarType) IsSetPrecision() bool {
	return p.Precision != nil
}

func (p *TScalarType) IsSetScale() bool {
	return p.Scale != nil
}

func (p *TScalarType) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetType bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetType = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetType{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"))
	}
	return nil
}

func (p *TScalarType) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := TPrimitiveType(v)
		p.Type = temp
	}
	return nil
}

func (p *TScalarType) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Len = &v
	}
	return nil
}

func (p *TScalarType) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Precision = &v
	}
	return nil
}

func (p *TScalarType) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Scale = &v
	}
	return nil
}

func (p *TScalarType) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TScalarType"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TScalarType) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err)
	}
	return err
}

func (p *TScalarType) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLen() {
		if err := oprot.WriteFieldBegin(ctx, "len", thrift.I32, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:len: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Len)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.len (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:len: ", p), err)
		}
	}
	return err
}

func (p *TScalarType) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetPrecision() {
		if err := oprot.WriteFieldBegin(ctx, "precision", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:precision: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Precision)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.precision (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:precision: ", p), err)
		}
	}
	return err
}

func (p *TScalarType) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetScale() {
		if err := oprot.WriteFieldBegin(ctx, "scale", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:scale: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Scale)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.scale (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:scale: ", p), err)
		}
	}
	return err
}

func (p *TScalarType) Equals(other *TScalarType) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Type != other.Type { return false }
	if p.Len != other.Len {
		if p.Len == nil || other.Len == nil {
			return false
		}
		if (*p.Len) != (*other.Len) { return false }
	}
	if p.Precision != other.Precision {
		if p.Precision == nil || other.Precision == nil {
			return false
		}
		if (*p.Precision) != (*other.Precision) { return false }
	}
	if p.Scale != other.Scale {
		if p.Scale == nil || other.Scale == nil {
			return false
		}
		if (*p.Scale) != (*other.Scale) { return false }
	}
	return true
}

func (p *TScalarType) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TScalarType(%+v)", *p)
}

func (p *TScalarType) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TScalarType",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TScalarType)(nil)

func (p *TScalarType) Validate() error {
	return nil
}

// Attributes:
//  - Name
//  - Comment
//  - FieldID
// 
type TStructField struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
	Comment *string `thrift:"comment,2" db:"comment" json:"comment,omitempty"`
	FieldID *int32 `thrift:"field_id,3" db:"field_id" json:"field_id,omitempty"`
}

func NewTStructField() *TStructField {
	return &TStructField{}
}



func (p *TStructField) GetName() string {
	return p.Name
}

var TStructField_Comment_DEFAULT string

func (p *TStructField) GetComment() string {
	if !p.IsSetComment() {
		return TStructField_Comment_DEFAULT
	}
	return *p.Comment
}

var TStructField_FieldID_DEFAULT int32

func (p *TStructField) GetFieldID() int32 {
	if !p.IsSetFieldID() {
		return TStructField_FieldID_DEFAULT
	}
	return *p.FieldID
}

func (p *TStructField) IsSetComment() bool {
	return p.Comment != nil
}

func (p *TStructField) IsSetFieldID() bool {
	return p.FieldID != nil
}

func (p *TStructField) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *TStructField) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *TStructField) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Comment = &v
	}
	return nil
}

func (p *TStructField) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.FieldID = &v
	}
	return nil
}

func (p *TStructField) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TStructField"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TStructField) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *TStructField) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetComment() {
		if err := oprot.WriteFieldBegin(ctx, "comment", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:comment: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Comment)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comment (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:comment: ", p), err)
		}
	}
	return err
}

func (p *TStructField) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFieldID() {
		if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:field_id: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.FieldID)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.field_id (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:field_id: ", p), err)
		}
	}
	return err
}

func (p *TStructField) Equals(other *TStructField) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Name != other.Name { return false }
	if p.Comment != other.Comment {
		if p.Comment == nil || other.Comment == nil {
			return false
		}
		if (*p.Comment) != (*other.Comment) { return false }
	}
	if p.FieldID != other.FieldID {
		if p.FieldID == nil || other.FieldID == nil {
			return false
		}
		if (*p.FieldID) != (*other.FieldID) { return false }
	}
	return true
}

func (p *TStructField) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TStructField(%+v)", *p)
}

func (p *TStructField) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TStructField",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TStructField)(nil)

func (p *TStructField) Validate() error {
	return nil
}

// Attributes:
//  - Type
//  - ScalarType
//  - StructFields
// 
type TTypeNode struct {
	Type TTypeNodeType `thrift:"type,1,required" db:"type" json:"type"`
	ScalarType *TScalarType `thrift:"scalar_type,2" db:"scalar_type" json:"scalar_type,omitempty"`
	StructFields []*TStructField `thrift:"struct_fields,3" db:"struct_fields" json:"struct_fields,omitempty"`
}

func NewTTypeNode() *TTypeNode {
	return &TTypeNode{}
}



func (p *TTypeNode) GetType() TTypeNodeType {
	return p.Type
}

var TTypeNode_ScalarType_DEFAULT *TScalarType

func (p *TTypeNode) GetScalarType() *TScalarType {
	if !p.IsSetScalarType() {
		return TTypeNode_ScalarType_DEFAULT
	}
	return p.ScalarType
}

var TTypeNode_StructFields_DEFAULT []*TStructField


func (p *TTypeNode) GetStructFields() []*TStructField {
	return p.StructFields
}

func (p *TTypeNode) IsSetScalarType() bool {
	return p.ScalarType != nil
}

func (p *TTypeNode) IsSetStructFields() bool {
	return p.StructFields != nil
}

func (p *TTypeNode) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetType bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetType = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetType{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"))
	}
	return nil
}

func (p *TTypeNode) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := TTypeNodeType(v)
		p.Type = temp
	}
	return nil
}

func (p *TTypeNode) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.ScalarType = &TScalarType{}
	if err := p.ScalarType.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ScalarType), err)
	}
	return nil
}

func (p *TTypeNode) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TStructField, 0, size)
	p.StructFields = tSlice
	for i := 0; i < size; i++ {
		_elem0 := &TStructField{}
		if err := _elem0.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
		}
		p.StructFields = append(p.StructFields, _elem0)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TTypeNode) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TTypeNode"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TTypeNode) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err)
	}
	return err
}

func (p *TTypeNode) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetScalarType() {
		if err := oprot.WriteFieldBegin(ctx, "scalar_type", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scalar_type: ", p), err)
		}
		if err := p.ScalarType.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ScalarType), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scalar_type: ", p), err)
		}
	}
	return err
}

func (p *TTypeNode) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStructFields() {
		if err := oprot.WriteFieldBegin(ctx, "struct_fields", thrift.LIST, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:struct_fields: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.StructFields)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.StructFields {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:struct_fields: ", p), err)
		}
	}
	return err
}

func (p *TTypeNode) Equals(other *TTypeNode) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Type != other.Type { return false }
	if !p.ScalarType.Equals(other.ScalarType) { return false }
	if len(p.StructFields) != len(other.StructFields) { return false }
	for i, _tgt := range p.StructFields {
		_src1 := other.StructFields[i]
		if !_tgt.Equals(_src1) { return false }
	}
	return true
}

func (p *TTypeNode) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TTypeNode(%+v)", *p)
}

func (p *TTypeNode) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TTypeNode",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TTypeNode)(nil)

func (p *TTypeNode) Validate() error {
	return nil
}

// Attributes:
//  - Types
// 
type TColumnType struct {
	Types []*TTypeNode `thrift:"types,1" db:"types" json:"types"`
}

func NewTColumnType() *TColumnType {
	return &TColumnType{}
}



func (p *TColumnType) GetTypes() []*TTypeNode {
	return p.Types
}

func (p *TColumnType) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TColumnType) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTypeNode, 0, size)
	p.Types = tSlice
	for i := 0; i < size; i++ {
		_elem2 := &TTypeNode{}
		if err := _elem2.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
		}
		p.Types = append(p.Types, _elem2)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TColumnType) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TColumnType"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TColumnType) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "types", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:types: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Types)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Types {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:types: ", p), err)
	}
	return err
}

func (p *TColumnType) Equals(other *TColumnType) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Types) != len(other.Types) { return false }
	for i, _tgt := range p.Types {
		_src3 := other.Types[i]
		if !_tgt.Equals(_src3) { return false }
	}
	return true
}

func (p *TColumnType) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TColumnType(%+v)", *p)
}

func (p *TColumnType) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TColumnType",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TColumnType)(nil)

func (p *TColumnType) Validate() error {
	return nil
}

// Attributes:
//  - Hostname
//  - Port
//  - UdsAddress
// 
type TNetworkAddress struct {
	Hostname string `thrift:"hostname,1,required" db:"hostname" json:"hostname"`
	Port int32 `thrift:"port,2,required" db:"port" json:"port"`
	UdsAddress *string `thrift:"uds_address,3" db:"uds_address" json:"uds_address,omitempty"`
}

func NewTNetworkAddress() *TNetworkAddress {
	return &TNetworkAddress{}
}



func (p *TNetworkAddress) GetHostname() string {
	return p.Hostname
}



func (p *TNetworkAddress) GetPort() int32 {
	return p.Port
}

var TNetworkAddress_UdsAddress_DEFAULT string

func (p *TNetworkAddress) GetUdsAddress() string {
	if !p.IsSetUdsAddress() {
		return TNetworkAddress_UdsAddress_DEFAULT
	}
	return *p.UdsAddress
}

func (p *TNetworkAddress) IsSetUdsAddress() bool {
	return p.UdsAddress != nil
}

func (p *TNetworkAddress) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetHostname bool = false;
	var issetPort bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetHostname = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetPort = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetHostname{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Hostname is not set"))
	}
	if !issetPort{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Port is not set"))
	}
	return nil
}

func (p *TNetworkAddress) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Hostname = v
	}
	return nil
}

func (p *TNetworkAddress) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Port = v
	}
	return nil
}

func (p *TNetworkAddress) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.UdsAddress = &v
	}
	return nil
}

func (p *TNetworkAddress) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TNetworkAddress"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TNetworkAddress) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "hostname", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hostname: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Hostname)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.hostname (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hostname: ", p), err)
	}
	return err
}

func (p *TNetworkAddress) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:port: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Port)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.port (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:port: ", p), err)
	}
	return err
}

func (p *TNetworkAddress) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetUdsAddress() {
		if err := oprot.WriteFieldBegin(ctx, "uds_address", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:uds_address: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.UdsAddress)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.uds_address (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:uds_address: ", p), err)
		}
	}
	return err
}

func (p *TNetworkAddress) Equals(other *TNetworkAddress) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Hostname != other.Hostname { return false }
	if p.Port != other.Port { return false }
	if p.UdsAddress != other.UdsAddress {
		if p.UdsAddress == nil || other.UdsAddress == nil {
			return false
		}
		if (*p.UdsAddress) != (*other.UdsAddress) { return false }
	}
	return true
}

func (p *TNetworkAddress) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TNetworkAddress(%+v)", *p)
}

func (p *TNetworkAddress) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TNetworkAddress",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TNetworkAddress)(nil)

func (p *TNetworkAddress) Validate() error {
	return nil
}

// Attributes:
//  - Addresses
// 
type TAddressesList struct {
	Addresses []*TNetworkAddress `thrift:"addresses,1,required" db:"addresses" json:"addresses"`
}

func NewTAddressesList() *TAddressesList {
	return &TAddressesList{}
}



func (p *TAddressesList) GetAddresses() []*TNetworkAddress {
	return p.Addresses
}

func (p *TAddressesList) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetAddresses bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetAddresses = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetAddresses{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Addresses is not set"))
	}
	return nil
}

func (p *TAddressesList) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TNetworkAddress, 0, size)
	p.Addresses = tSlice
	for i := 0; i < size; i++ {
		_elem4 := &TNetworkAddress{}
		if err := _elem4.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
		}
		p.Addresses = append(p.Addresses, _elem4)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TAddressesList) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TAddressesList"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TAddressesList) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "addresses", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:addresses: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Addresses)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Addresses {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:addresses: ", p), err)
	}
	return err
}

func (p *TAddressesList) Equals(other *TAddressesList) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Addresses) != len(other.Addresses) { return false }
	for i, _tgt := range p.Addresses {
		_src5 := other.Addresses[i]
		if !_tgt.Equals(_src5) { return false }
	}
	return true
}

func (p *TAddressesList) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TAddressesList(%+v)", *p)
}

func (p *TAddressesList) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TAddressesList",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TAddressesList)(nil)

func (p *TAddressesList) Validate() error {
	return nil
}

// Attributes:
//  - Hi
//  - Lo
// 
type TUniqueId struct {
	Hi int64 `thrift:"hi,1,required" db:"hi" json:"hi"`
	Lo int64 `thrift:"lo,2,required" db:"lo" json:"lo"`
}

func NewTUniqueId() *TUniqueId {
	return &TUniqueId{}
}



func (p *TUniqueId) GetHi() int64 {
	return p.Hi
}



func (p *TUniqueId) GetLo() int64 {
	return p.Lo
}

func (p *TUniqueId) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetHi bool = false;
	var issetLo bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetHi = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetLo = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetHi{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Hi is not set"))
	}
	if !issetLo{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Lo is not set"))
	}
	return nil
}

func (p *TUniqueId) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Hi = v
	}
	return nil
}

func (p *TUniqueId) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Lo = v
	}
	return nil
}

func (p *TUniqueId) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TUniqueId"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TUniqueId) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "hi", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hi: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Hi)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.hi (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hi: ", p), err)
	}
	return err
}

func (p *TUniqueId) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "lo", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:lo: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Lo)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.lo (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:lo: ", p), err)
	}
	return err
}

func (p *TUniqueId) Equals(other *TUniqueId) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Hi != other.Hi { return false }
	if p.Lo != other.Lo { return false }
	return true
}

func (p *TUniqueId) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TUniqueId(%+v)", *p)
}

func (p *TUniqueId) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TUniqueId",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TUniqueId)(nil)

func (p *TUniqueId) Validate() error {
	return nil
}

// Attributes:
//  - DbName
//  - FunctionName
// 
type TFunctionName struct {
	DbName *string `thrift:"db_name,1" db:"db_name" json:"db_name,omitempty"`
	FunctionName string `thrift:"function_name,2,required" db:"function_name" json:"function_name"`
}

func NewTFunctionName() *TFunctionName {
	return &TFunctionName{}
}

var TFunctionName_DbName_DEFAULT string

func (p *TFunctionName) GetDbName() string {
	if !p.IsSetDbName() {
		return TFunctionName_DbName_DEFAULT
	}
	return *p.DbName
}



func (p *TFunctionName) GetFunctionName() string {
	return p.FunctionName
}

func (p *TFunctionName) IsSetDbName() bool {
	return p.DbName != nil
}

func (p *TFunctionName) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetFunctionName bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetFunctionName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetFunctionName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field FunctionName is not set"))
	}
	return nil
}

func (p *TFunctionName) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.DbName = &v
	}
	return nil
}

func (p *TFunctionName) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.FunctionName = v
	}
	return nil
}

func (p *TFunctionName) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TFunctionName"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TFunctionName) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDbName() {
		if err := oprot.WriteFieldBegin(ctx, "db_name", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:db_name: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.DbName)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.db_name (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:db_name: ", p), err)
		}
	}
	return err
}

func (p *TFunctionName) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "function_name", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:function_name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.FunctionName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.function_name (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:function_name: ", p), err)
	}
	return err
}

func (p *TFunctionName) Equals(other *TFunctionName) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.DbName != other.DbName {
		if p.DbName == nil || other.DbName == nil {
			return false
		}
		if (*p.DbName) != (*other.DbName) { return false }
	}
	if p.FunctionName != other.FunctionName { return false }
	return true
}

func (p *TFunctionName) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TFunctionName(%+v)", *p)
}

func (p *TFunctionName) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TFunctionName",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TFunctionName)(nil)

func (p *TFunctionName) Validate() error {
	return nil
}

// Attributes:
//  - Symbol
//  - PrepareFnSymbol
//  - CloseFnSymbol
// 
type TScalarFunction struct {
	Symbol string `thrift:"symbol,1,required" db:"symbol" json:"symbol"`
	PrepareFnSymbol *string `thrift:"prepare_fn_symbol,2" db:"prepare_fn_symbol" json:"prepare_fn_symbol,omitempty"`
	CloseFnSymbol *string `thrift:"close_fn_symbol,3" db:"close_fn_symbol" json:"close_fn_symbol,omitempty"`
}

func NewTScalarFunction() *TScalarFunction {
	return &TScalarFunction{}
}



func (p *TScalarFunction) GetSymbol() string {
	return p.Symbol
}

var TScalarFunction_PrepareFnSymbol_DEFAULT string

func (p *TScalarFunction) GetPrepareFnSymbol() string {
	if !p.IsSetPrepareFnSymbol() {
		return TScalarFunction_PrepareFnSymbol_DEFAULT
	}
	return *p.PrepareFnSymbol
}

var TScalarFunction_CloseFnSymbol_DEFAULT string

func (p *TScalarFunction) GetCloseFnSymbol() string {
	if !p.IsSetCloseFnSymbol() {
		return TScalarFunction_CloseFnSymbol_DEFAULT
	}
	return *p.CloseFnSymbol
}

func (p *TScalarFunction) IsSetPrepareFnSymbol() bool {
	return p.PrepareFnSymbol != nil
}

func (p *TScalarFunction) IsSetCloseFnSymbol() bool {
	return p.CloseFnSymbol != nil
}

func (p *TScalarFunction) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetSymbol bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetSymbol = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetSymbol{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Symbol is not set"))
	}
	return nil
}

func (p *TScalarFunction) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Symbol = v
	}
	return nil
}

func (p *TScalarFunction) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.PrepareFnSymbol = &v
	}
	return nil
}

func (p *TScalarFunction) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.CloseFnSymbol = &v
	}
	return nil
}

func (p *TScalarFunction) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TScalarFunction"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TScalarFunction) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "symbol", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:symbol: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Symbol)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.symbol (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:symbol: ", p), err)
	}
	return err
}

func (p *TScalarFunction) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetPrepareFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "prepare_fn_symbol", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:prepare_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.PrepareFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.prepare_fn_symbol (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:prepare_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TScalarFunction) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCloseFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "close_fn_symbol", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:close_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.CloseFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.close_fn_symbol (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:close_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TScalarFunction) Equals(other *TScalarFunction) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Symbol != other.Symbol { return false }
	if p.PrepareFnSymbol != other.PrepareFnSymbol {
		if p.PrepareFnSymbol == nil || other.PrepareFnSymbol == nil {
			return false
		}
		if (*p.PrepareFnSymbol) != (*other.PrepareFnSymbol) { return false }
	}
	if p.CloseFnSymbol != other.CloseFnSymbol {
		if p.CloseFnSymbol == nil || other.CloseFnSymbol == nil {
			return false
		}
		if (*p.CloseFnSymbol) != (*other.CloseFnSymbol) { return false }
	}
	return true
}

func (p *TScalarFunction) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TScalarFunction(%+v)", *p)
}

func (p *TScalarFunction) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TScalarFunction",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TScalarFunction)(nil)

func (p *TScalarFunction) Validate() error {
	return nil
}

// Attributes:
//  - IntermediateType
//  - IsAnalyticOnlyFn
//  - UpdateFnSymbol
//  - InitFnSymbol
//  - SerializeFnSymbol
//  - MergeFnSymbol
//  - FinalizeFnSymbol
//  - GetValueFnSymbol
//  - RemoveFnSymbol
//  - IgnoresDistinct
// 
type TAggregateFunction struct {
	IntermediateType *TColumnType `thrift:"intermediate_type,1,required" db:"intermediate_type" json:"intermediate_type"`
	IsAnalyticOnlyFn bool `thrift:"is_analytic_only_fn,2,required" db:"is_analytic_only_fn" json:"is_analytic_only_fn"`
	UpdateFnSymbol string `thrift:"update_fn_symbol,3,required" db:"update_fn_symbol" json:"update_fn_symbol"`
	InitFnSymbol string `thrift:"init_fn_symbol,4,required" db:"init_fn_symbol" json:"init_fn_symbol"`
	SerializeFnSymbol *string `thrift:"serialize_fn_symbol,5" db:"serialize_fn_symbol" json:"serialize_fn_symbol,omitempty"`
	MergeFnSymbol *string `thrift:"merge_fn_symbol,6" db:"merge_fn_symbol" json:"merge_fn_symbol,omitempty"`
	FinalizeFnSymbol *string `thrift:"finalize_fn_symbol,7" db:"finalize_fn_symbol" json:"finalize_fn_symbol,omitempty"`
	GetValueFnSymbol *string `thrift:"get_value_fn_symbol,8" db:"get_value_fn_symbol" json:"get_value_fn_symbol,omitempty"`
	RemoveFnSymbol *string `thrift:"remove_fn_symbol,9" db:"remove_fn_symbol" json:"remove_fn_symbol,omitempty"`
	IgnoresDistinct *bool `thrift:"ignores_distinct,10" db:"ignores_distinct" json:"ignores_distinct,omitempty"`
}

func NewTAggregateFunction() *TAggregateFunction {
	return &TAggregateFunction{}
}

var TAggregateFunction_IntermediateType_DEFAULT *TColumnType

func (p *TAggregateFunction) GetIntermediateType() *TColumnType {
	if !p.IsSetIntermediateType() {
		return TAggregateFunction_IntermediateType_DEFAULT
	}
	return p.IntermediateType
}



func (p *TAggregateFunction) GetIsAnalyticOnlyFn() bool {
	return p.IsAnalyticOnlyFn
}



func (p *TAggregateFunction) GetUpdateFnSymbol() string {
	return p.UpdateFnSymbol
}



func (p *TAggregateFunction) GetInitFnSymbol() string {
	return p.InitFnSymbol
}

var TAggregateFunction_SerializeFnSymbol_DEFAULT string

func (p *TAggregateFunction) GetSerializeFnSymbol() string {
	if !p.IsSetSerializeFnSymbol() {
		return TAggregateFunction_SerializeFnSymbol_DEFAULT
	}
	return *p.SerializeFnSymbol
}

var TAggregateFunction_MergeFnSymbol_DEFAULT string

func (p *TAggregateFunction) GetMergeFnSymbol() string {
	if !p.IsSetMergeFnSymbol() {
		return TAggregateFunction_MergeFnSymbol_DEFAULT
	}
	return *p.MergeFnSymbol
}

var TAggregateFunction_FinalizeFnSymbol_DEFAULT string

func (p *TAggregateFunction) GetFinalizeFnSymbol() string {
	if !p.IsSetFinalizeFnSymbol() {
		return TAggregateFunction_FinalizeFnSymbol_DEFAULT
	}
	return *p.FinalizeFnSymbol
}

var TAggregateFunction_GetValueFnSymbol_DEFAULT string

func (p *TAggregateFunction) GetGetValueFnSymbol() string {
	if !p.IsSetGetValueFnSymbol() {
		return TAggregateFunction_GetValueFnSymbol_DEFAULT
	}
	return *p.GetValueFnSymbol
}

var TAggregateFunction_RemoveFnSymbol_DEFAULT string

func (p *TAggregateFunction) GetRemoveFnSymbol() string {
	if !p.IsSetRemoveFnSymbol() {
		return TAggregateFunction_RemoveFnSymbol_DEFAULT
	}
	return *p.RemoveFnSymbol
}

var TAggregateFunction_IgnoresDistinct_DEFAULT bool

func (p *TAggregateFunction) GetIgnoresDistinct() bool {
	if !p.IsSetIgnoresDistinct() {
		return TAggregateFunction_IgnoresDistinct_DEFAULT
	}
	return *p.IgnoresDistinct
}

func (p *TAggregateFunction) IsSetIntermediateType() bool {
	return p.IntermediateType != nil
}

func (p *TAggregateFunction) IsSetSerializeFnSymbol() bool {
	return p.SerializeFnSymbol != nil
}

func (p *TAggregateFunction) IsSetMergeFnSymbol() bool {
	return p.MergeFnSymbol != nil
}

func (p *TAggregateFunction) IsSetFinalizeFnSymbol() bool {
	return p.FinalizeFnSymbol != nil
}

func (p *TAggregateFunction) IsSetGetValueFnSymbol() bool {
	return p.GetValueFnSymbol != nil
}

func (p *TAggregateFunction) IsSetRemoveFnSymbol() bool {
	return p.RemoveFnSymbol != nil
}

func (p *TAggregateFunction) IsSetIgnoresDistinct() bool {
	return p.IgnoresDistinct != nil
}

func (p *TAggregateFunction) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIntermediateType bool = false;
	var issetIsAnalyticOnlyFn bool = false;
	var issetUpdateFnSymbol bool = false;
	var issetInitFnSymbol bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetIntermediateType = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetIsAnalyticOnlyFn = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetUpdateFnSymbol = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetInitFnSymbol = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIntermediateType{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IntermediateType is not set"))
	}
	if !issetIsAnalyticOnlyFn{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IsAnalyticOnlyFn is not set"))
	}
	if !issetUpdateFnSymbol{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UpdateFnSymbol is not set"))
	}
	if !issetInitFnSymbol{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field InitFnSymbol is not set"))
	}
	return nil
}

func (p *TAggregateFunction) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.IntermediateType = &TColumnType{}
	if err := p.IntermediateType.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.IntermediateType), err)
	}
	return nil
}

func (p *TAggregateFunction) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IsAnalyticOnlyFn = v
	}
	return nil
}

func (p *TAggregateFunction) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.UpdateFnSymbol = v
	}
	return nil
}

func (p *TAggregateFunction) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.InitFnSymbol = v
	}
	return nil
}

func (p *TAggregateFunction) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.SerializeFnSymbol = &v
	}
	return nil
}

func (p *TAggregateFunction) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.MergeFnSymbol = &v
	}
	return nil
}

func (p *TAggregateFunction) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.FinalizeFnSymbol = &v
	}
	return nil
}

func (p *TAggregateFunction) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.GetValueFnSymbol = &v
	}
	return nil
}

func (p *TAggregateFunction) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.RemoveFnSymbol = &v
	}
	return nil
}

func (p *TAggregateFunction) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.IgnoresDistinct = &v
	}
	return nil
}

func (p *TAggregateFunction) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TAggregateFunction"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TAggregateFunction) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "intermediate_type", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:intermediate_type: ", p), err)
	}
	if err := p.IntermediateType.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.IntermediateType), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:intermediate_type: ", p), err)
	}
	return err
}

func (p *TAggregateFunction) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "is_analytic_only_fn", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:is_analytic_only_fn: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.IsAnalyticOnlyFn)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.is_analytic_only_fn (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:is_analytic_only_fn: ", p), err)
	}
	return err
}

func (p *TAggregateFunction) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "update_fn_symbol", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:update_fn_symbol: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.UpdateFnSymbol)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.update_fn_symbol (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:update_fn_symbol: ", p), err)
	}
	return err
}

func (p *TAggregateFunction) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "init_fn_symbol", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:init_fn_symbol: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.InitFnSymbol)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.init_fn_symbol (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:init_fn_symbol: ", p), err)
	}
	return err
}

func (p *TAggregateFunction) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSerializeFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "serialize_fn_symbol", thrift.STRING, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:serialize_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.SerializeFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.serialize_fn_symbol (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:serialize_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TAggregateFunction) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMergeFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "merge_fn_symbol", thrift.STRING, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:merge_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.MergeFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.merge_fn_symbol (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:merge_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TAggregateFunction) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFinalizeFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "finalize_fn_symbol", thrift.STRING, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:finalize_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.FinalizeFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.finalize_fn_symbol (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:finalize_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TAggregateFunction) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetGetValueFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "get_value_fn_symbol", thrift.STRING, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:get_value_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.GetValueFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.get_value_fn_symbol (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:get_value_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TAggregateFunction) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRemoveFnSymbol() {
		if err := oprot.WriteFieldBegin(ctx, "remove_fn_symbol", thrift.STRING, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:remove_fn_symbol: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.RemoveFnSymbol)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.remove_fn_symbol (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:remove_fn_symbol: ", p), err)
		}
	}
	return err
}

func (p *TAggregateFunction) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIgnoresDistinct() {
		if err := oprot.WriteFieldBegin(ctx, "ignores_distinct", thrift.BOOL, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:ignores_distinct: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.IgnoresDistinct)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ignores_distinct (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:ignores_distinct: ", p), err)
		}
	}
	return err
}

func (p *TAggregateFunction) Equals(other *TAggregateFunction) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.IntermediateType.Equals(other.IntermediateType) { return false }
	if p.IsAnalyticOnlyFn != other.IsAnalyticOnlyFn { return false }
	if p.UpdateFnSymbol != other.UpdateFnSymbol { return false }
	if p.InitFnSymbol != other.InitFnSymbol { return false }
	if p.SerializeFnSymbol != other.SerializeFnSymbol {
		if p.SerializeFnSymbol == nil || other.SerializeFnSymbol == nil {
			return false
		}
		if (*p.SerializeFnSymbol) != (*other.SerializeFnSymbol) { return false }
	}
	if p.MergeFnSymbol != other.MergeFnSymbol {
		if p.MergeFnSymbol == nil || other.MergeFnSymbol == nil {
			return false
		}
		if (*p.MergeFnSymbol) != (*other.MergeFnSymbol) { return false }
	}
	if p.FinalizeFnSymbol != other.FinalizeFnSymbol {
		if p.FinalizeFnSymbol == nil || other.FinalizeFnSymbol == nil {
			return false
		}
		if (*p.FinalizeFnSymbol) != (*other.FinalizeFnSymbol) { return false }
	}
	if p.GetValueFnSymbol != other.GetValueFnSymbol {
		if p.GetValueFnSymbol == nil || other.GetValueFnSymbol == nil {
			return false
		}
		if (*p.GetValueFnSymbol) != (*other.GetValueFnSymbol) { return false }
	}
	if p.RemoveFnSymbol != other.RemoveFnSymbol {
		if p.RemoveFnSymbol == nil || other.RemoveFnSymbol == nil {
			return false
		}
		if (*p.RemoveFnSymbol) != (*other.RemoveFnSymbol) { return false }
	}
	if p.IgnoresDistinct != other.IgnoresDistinct {
		if p.IgnoresDistinct == nil || other.IgnoresDistinct == nil {
			return false
		}
		if (*p.IgnoresDistinct) != (*other.IgnoresDistinct) { return false }
	}
	return true
}

func (p *TAggregateFunction) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TAggregateFunction(%+v)", *p)
}

func (p *TAggregateFunction) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TAggregateFunction",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TAggregateFunction)(nil)

func (p *TAggregateFunction) Validate() error {
	return nil
}

// Attributes:
//  - Name
//  - BinaryType
//  - ArgTypes
//  - RetType
//  - HasVarArgs_
//  - Comment
//  - Signature
//  - HdfsLocation
//  - ScalarFn
//  - AggregateFn
//  - IsPersistent
//  - LastModifiedTime
// 
type TFunction struct {
	Name *TFunctionName `thrift:"name,1,required" db:"name" json:"name"`
	BinaryType *TFunctionBinaryType `thrift:"binary_type,2" db:"binary_type" json:"binary_type,omitempty"`
	ArgTypes []*TColumnType `thrift:"arg_types,3" db:"arg_types" json:"arg_types,omitempty"`
	RetType *TColumnType `thrift:"ret_type,4" db:"ret_type" json:"ret_type,omitempty"`
	HasVarArgs_ *bool `thrift:"has_var_args,5" db:"has_var_args" json:"has_var_args,omitempty"`
	Comment *string `thrift:"comment,6" db:"comment" json:"comment,omitempty"`
	Signature *string `thrift:"signature,7" db:"signature" json:"signature,omitempty"`
	HdfsLocation *string `thrift:"hdfs_location,8" db:"hdfs_location" json:"hdfs_location,omitempty"`
	ScalarFn *TScalarFunction `thrift:"scalar_fn,9" db:"scalar_fn" json:"scalar_fn,omitempty"`
	AggregateFn *TAggregateFunction `thrift:"aggregate_fn,10" db:"aggregate_fn" json:"aggregate_fn,omitempty"`
	IsPersistent *bool `thrift:"is_persistent,11" db:"is_persistent" json:"is_persistent,omitempty"`
	LastModifiedTime *int64 `thrift:"last_modified_time,12" db:"last_modified_time" json:"last_modified_time,omitempty"`
}

func NewTFunction() *TFunction {
	return &TFunction{}
}

var TFunction_Name_DEFAULT *TFunctionName

func (p *TFunction) GetName() *TFunctionName {
	if !p.IsSetName() {
		return TFunction_Name_DEFAULT
	}
	return p.Name
}

var TFunction_BinaryType_DEFAULT TFunctionBinaryType

func (p *TFunction) GetBinaryType() TFunctionBinaryType {
	if !p.IsSetBinaryType() {
		return TFunction_BinaryType_DEFAULT
	}
	return *p.BinaryType
}

var TFunction_ArgTypes_DEFAULT []*TColumnType


func (p *TFunction) GetArgTypes() []*TColumnType {
	return p.ArgTypes
}

var TFunction_RetType_DEFAULT *TColumnType

func (p *TFunction) GetRetType() *TColumnType {
	if !p.IsSetRetType() {
		return TFunction_RetType_DEFAULT
	}
	return p.RetType
}

var TFunction_HasVarArgs__DEFAULT bool

func (p *TFunction) GetHasVarArgs_() bool {
	if !p.IsSetHasVarArgs_() {
		return TFunction_HasVarArgs__DEFAULT
	}
	return *p.HasVarArgs_
}

var TFunction_Comment_DEFAULT string

func (p *TFunction) GetComment() string {
	if !p.IsSetComment() {
		return TFunction_Comment_DEFAULT
	}
	return *p.Comment
}

var TFunction_Signature_DEFAULT string

func (p *TFunction) GetSignature() string {
	if !p.IsSetSignature() {
		return TFunction_Signature_DEFAULT
	}
	return *p.Signature
}

var TFunction_HdfsLocation_DEFAULT string

func (p *TFunction) GetHdfsLocation() string {
	if !p.IsSetHdfsLocation() {
		return TFunction_HdfsLocation_DEFAULT
	}
	return *p.HdfsLocation
}

var TFunction_ScalarFn_DEFAULT *TScalarFunction

func (p *TFunction) GetScalarFn() *TScalarFunction {
	if !p.IsSetScalarFn() {
		return TFunction_ScalarFn_DEFAULT
	}
	return p.ScalarFn
}

var TFunction_AggregateFn_DEFAULT *TAggregateFunction

func (p *TFunction) GetAggregateFn() *TAggregateFunction {
	if !p.IsSetAggregateFn() {
		return TFunction_AggregateFn_DEFAULT
	}
	return p.AggregateFn
}

var TFunction_IsPersistent_DEFAULT bool

func (p *TFunction) GetIsPersistent() bool {
	if !p.IsSetIsPersistent() {
		return TFunction_IsPersistent_DEFAULT
	}
	return *p.IsPersistent
}

var TFunction_LastModifiedTime_DEFAULT int64

func (p *TFunction) GetLastModifiedTime() int64 {
	if !p.IsSetLastModifiedTime() {
		return TFunction_LastModifiedTime_DEFAULT
	}
	return *p.LastModifiedTime
}

func (p *TFunction) IsSetName() bool {
	return p.Name != nil
}

func (p *TFunction) IsSetBinaryType() bool {
	return p.BinaryType != nil
}

func (p *TFunction) IsSetArgTypes() bool {
	return p.ArgTypes != nil
}

func (p *TFunction) IsSetRetType() bool {
	return p.RetType != nil
}

func (p *TFunction) IsSetHasVarArgs_() bool {
	return p.HasVarArgs_ != nil
}

func (p *TFunction) IsSetComment() bool {
	return p.Comment != nil
}

func (p *TFunction) IsSetSignature() bool {
	return p.Signature != nil
}

func (p *TFunction) IsSetHdfsLocation() bool {
	return p.HdfsLocation != nil
}

func (p *TFunction) IsSetScalarFn() bool {
	return p.ScalarFn != nil
}

func (p *TFunction) IsSetAggregateFn() bool {
	return p.AggregateFn != nil
}

func (p *TFunction) IsSetIsPersistent() bool {
	return p.IsPersistent != nil
}

func (p *TFunction) IsSetLastModifiedTime() bool {
	return p.LastModifiedTime != nil
}

func (p *TFunction) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *TFunction) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Name = &TFunctionName{}
	if err := p.Name.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
	}
	return nil
}

func (p *TFunction) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := TFunctionBinaryType(v)
		p.BinaryType = &temp
	}
	return nil
}

func (p *TFunction) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumnType, 0, size)
	p.ArgTypes = tSlice
	for i := 0; i < size; i++ {
		_elem6 := &TColumnType{}
		if err := _elem6.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem6), err)
		}
		p.ArgTypes = append(p.ArgTypes, _elem6)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TFunction) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.RetType = &TColumnType{}
	if err := p.RetType.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RetType), err)
	}
	return nil
}

func (p *TFunction) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.HasVarArgs_ = &v
	}
	return nil
}

func (p *TFunction) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.Comment = &v
	}
	return nil
}

func (p *TFunction) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.Signature = &v
	}
	return nil
}

func (p *TFunction) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.HdfsLocation = &v
	}
	return nil
}

func (p *TFunction) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	p.ScalarFn = &TScalarFunction{}
	if err := p.ScalarFn.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ScalarFn), err)
	}
	return nil
}

func (p *TFunction) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	p.AggregateFn = &TAggregateFunction{}
	if err := p.AggregateFn.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AggregateFn), err)
	}
	return nil
}

func (p *TFunction) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.IsPersistent = &v
	}
	return nil
}

func (p *TFunction) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.LastModifiedTime = &v
	}
	return nil
}

func (p *TFunction) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TFunction"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
		if err := p.writeField12(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TFunction) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := p.Name.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *TFunction) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBinaryType() {
		if err := oprot.WriteFieldBegin(ctx, "binary_type", thrift.I32, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:binary_type: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.BinaryType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.binary_type (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:binary_type: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetArgTypes() {
		if err := oprot.WriteFieldBegin(ctx, "arg_types", thrift.LIST, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:arg_types: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ArgTypes)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.ArgTypes {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:arg_types: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRetType() {
		if err := oprot.WriteFieldBegin(ctx, "ret_type", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ret_type: ", p), err)
		}
		if err := p.RetType.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RetType), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ret_type: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetHasVarArgs_() {
		if err := oprot.WriteFieldBegin(ctx, "has_var_args", thrift.BOOL, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:has_var_args: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.HasVarArgs_)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.has_var_args (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:has_var_args: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetComment() {
		if err := oprot.WriteFieldBegin(ctx, "comment", thrift.STRING, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:comment: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Comment)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comment (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:comment: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSignature() {
		if err := oprot.WriteFieldBegin(ctx, "signature", thrift.STRING, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:signature: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Signature)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.signature (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:signature: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetHdfsLocation() {
		if err := oprot.WriteFieldBegin(ctx, "hdfs_location", thrift.STRING, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:hdfs_location: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.HdfsLocation)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.hdfs_location (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:hdfs_location: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetScalarFn() {
		if err := oprot.WriteFieldBegin(ctx, "scalar_fn", thrift.STRUCT, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:scalar_fn: ", p), err)
		}
		if err := p.ScalarFn.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ScalarFn), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:scalar_fn: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAggregateFn() {
		if err := oprot.WriteFieldBegin(ctx, "aggregate_fn", thrift.STRUCT, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:aggregate_fn: ", p), err)
		}
		if err := p.AggregateFn.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AggregateFn), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:aggregate_fn: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIsPersistent() {
		if err := oprot.WriteFieldBegin(ctx, "is_persistent", thrift.BOOL, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:is_persistent: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.IsPersistent)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.is_persistent (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:is_persistent: ", p), err)
		}
	}
	return err
}

func (p *TFunction) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLastModifiedTime() {
		if err := oprot.WriteFieldBegin(ctx, "last_modified_time", thrift.I64, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:last_modified_time: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.LastModifiedTime)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.last_modified_time (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:last_modified_time: ", p), err)
		}
	}
	return err
}

func (p *TFunction) Equals(other *TFunction) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Name.Equals(other.Name) { return false }
	if p.BinaryType != other.BinaryType {
		if p.BinaryType == nil || other.BinaryType == nil {
			return false
		}
		if (*p.BinaryType) != (*other.BinaryType) { return false }
	}
	if len(p.ArgTypes) != len(other.ArgTypes) { return false }
	for i, _tgt := range p.ArgTypes {
		_src7 := other.ArgTypes[i]
		if !_tgt.Equals(_src7) { return false }
	}
	if !p.RetType.Equals(other.RetType) { return false }
	if p.HasVarArgs_ != other.HasVarArgs_ {
		if p.HasVarArgs_ == nil || other.HasVarArgs_ == nil {
			return false
		}
		if (*p.HasVarArgs_) != (*other.HasVarArgs_) { return false }
	}
	if p.Comment != other.Comment {
		if p.Comment == nil || other.Comment == nil {
			return false
		}
		if (*p.Comment) != (*other.Comment) { return false }
	}
	if p.Signature != other.Signature {
		if p.Signature == nil || other.Signature == nil {
			return false
		}
		if (*p.Signature) != (*other.Signature) { return false }
	}
	if p.HdfsLocation != other.HdfsLocation {
		if p.HdfsLocation == nil || other.HdfsLocation == nil {
			return false
		}
		if (*p.HdfsLocation) != (*other.HdfsLocation) { return false }
	}
	if !p.ScalarFn.Equals(other.ScalarFn) { return false }
	if !p.AggregateFn.Equals(other.AggregateFn) { return false }
	if p.IsPersistent != other.IsPersistent {
		if p.IsPersistent == nil || other.IsPersistent == nil {
			return false
		}
		if (*p.IsPersistent) != (*other.IsPersistent) { return false }
	}
	if p.LastModifiedTime != other.LastModifiedTime {
		if p.LastModifiedTime == nil || other.LastModifiedTime == nil {
			return false
		}
		if (*p.LastModifiedTime) != (*other.LastModifiedTime) { return false }
	}
	return true
}

func (p *TFunction) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TFunction(%+v)", *p)
}

func (p *TFunction) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*types.TFunction",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TFunction)(nil)

func (p *TFunction) Validate() error {
	return nil
}

